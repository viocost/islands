/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([326,1]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ 144:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 214:
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(215);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(216)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ 215:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 247:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 249:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 282:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 283:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 326:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.constructor.js
var es6_regexp_constructor = __webpack_require__(192);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js
var es6_regexp_split = __webpack_require__(115);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.symbol.async-iterator.js
var es7_symbol_async_iterator = __webpack_require__(119);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js
var es6_symbol = __webpack_require__(122);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.promise.js
var es6_promise = __webpack_require__(126);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(38);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __webpack_require__(210);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(76);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.to-string.js
var es6_object_to_string = __webpack_require__(52);

// EXTERNAL MODULE: ./client/src/css/main.sass
var main = __webpack_require__(214);

// EXTERNAL MODULE: ./node_modules/toastr/toastr.js
var toastr = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint16-array.js
var es6_typed_uint16_array = __webpack_require__(220);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __webpack_require__(226);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.typed.uint8-array.js
var es6_typed_uint8_array = __webpack_require__(227);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __webpack_require__(228);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __webpack_require__(230);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(22);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/js-chacha20/src/jschacha20.js
var jschacha20 = __webpack_require__(110);
var jschacha20_default = /*#__PURE__*/__webpack_require__.n(jschacha20);

// EXTERNAL MODULE: ./node_modules/node-forge/lib/index.js
var lib = __webpack_require__(0);

// CONCATENATED MODULE: ./client/src/js/lib/iCrypto.js
















var sjcl = __webpack_require__(244);

var iCrypto_iCrypto =
/*#__PURE__*/
function () {
  function iCrypto() {
    classCallCheck_default()(this, iCrypto);

    var self = this;
    self.settings = {};
    self.locked = false;
    self.setEncodersAndDecoders();
    self.symCiphers = ['aes'];
    self.streamCiphers = ['chacha'];
    self.asymCiphers = ['rsa'];
    self.store = {};
    self.rsa = {
      createKeyPair: function createKeyPair() {
        return self.generateRSAKeyPair.apply(self, arguments);
      },
      asyncCreateKeyPair: function asyncCreateKeyPair() {
        return self.asyncGenerateRSAKeyPair.apply(self, arguments);
      },
      encrypt: function encrypt() {
        return self.publicKeyEncrypt.apply(self, arguments);
      },
      decrypt: function decrypt() {
        return self.privateKeyDecrypt.apply(self, arguments);
      },
      sign: function sign() {
        return self.privateKeySign.apply(self, arguments);
      },
      verify: function verify() {
        return self.publicKeyVerify.apply(self, arguments);
      },
      setKey: function setKey() {
        return self.setRSAKey.apply(self, arguments);
      },
      getSettings: function getSettings() {
        return "RSA";
      }
    };
    self.aes = {
      modes: ['CBC', 'CFB', 'CTR'],
      mode: 'CBC',
      ivLength: 16,
      keySize: 32,
      createKey: function createKey() {
        return self.createSYMKey.apply(self, arguments);
      },
      encrypt: function encrypt() {
        return self.AESEncrypt.apply(self, arguments);
      },
      decrypt: function decrypt() {
        return self.AESDecrypt.apply(self, arguments);
      },
      setKey: function setKey() {
        return self.setSYMKey.apply(self, arguments);
      },
      getSettings: function getSettings() {
        return "AES";
      }
    };
    self.chacha = {
      init: function init() {
        return self.initStreamCryptor.apply(self, arguments);
      },
      encrypt: function encrypt() {
        return self.streamCryptorEncrypt.apply(self, arguments);
      },
      decrypt: function decrypt() {
        return self.streamCryptorDecrypt.apply(self, arguments);
      },
      getSettings: function getSettings() {
        return "ChaCha";
      }
    };
    self.setAsymCipher('rsa');
    self.setSymCipher('aes');
    self.setStreamCipher('chacha');
  }
  /***************** SETTING CIPHERS API *******************/


  createClass_default()(iCrypto, [{
    key: "setSymCipher",
    value: function setSymCipher() {
      var self = this;

      for (var _len = arguments.length, opts = new Array(_len), _key = 0; _key < _len; _key++) {
        opts[_key] = arguments[_key];
      }

      if (!self.symCiphers.includes(opts[0])) {
        throw "setSymCipher: Invalid or unsupported algorithm";
      }

      self.sym = self[opts[0]];
    }
  }, {
    key: "setAsymCipher",
    value: function setAsymCipher() {
      var self = this;

      for (var _len2 = arguments.length, opts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        opts[_key2] = arguments[_key2];
      }

      if (!self.asymCiphers.includes(opts[0])) {
        throw "setSymCipher: Invalid or unsupported algorithm";
      }

      self.asym = self[opts[0]];
    }
  }, {
    key: "setStreamCipher",
    value: function setStreamCipher() {
      var self = this;

      for (var _len3 = arguments.length, opts = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        opts[_key3] = arguments[_key3];
      }

      if (!self.streamCiphers.includes(opts[0])) {
        throw "setSymCipher: Invalid or unsupported algorithm";
      }

      self.ssym = self[opts[0]];
    }
    /***************** END **********************************/

  }, {
    key: "setEncodersAndDecoders",
    value: function setEncodersAndDecoders() {
      this.encoders = {
        hex: iCrypto.hexEncode,
        base64: iCrypto.base64Encode
      };
      this.decoders = {
        hex: iCrypto.hexDecode,
        base64: iCrypto.base64Decode
      };
    }
    /*********MAIN METHODS**************/

    /**********************$$*****************************/

    /***####NONCES PLAIN TEXT####***/

  }, {
    key: "asyncCreateNonce",
    value: function asyncCreateNonce(nameToSave) {
      var _this = this;

      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      return new Promise(function (resolve, reject) {
        try {
          resolve(_this.createNonce(nameToSave, length));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * Creates nonce of the given length and
     * saves it under the provided name.
     * Default is 32 bytes
     *
     * @param {string} nameToSave
     * @param {number} length
     * @returns {iCrypto}
     */

  }, {
    key: "createNonce",
    value: function createNonce() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("createNonce");
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      var self = this;
      this.set(nameToSave, iCrypto.getBytes(length));
      return this;
    }
  }, {
    key: "asyncAddBlob",
    value: function asyncAddBlob(nameToSave, plainText) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this2.addBlob(nameToSave, plainText));
        } catch (err) {
          reject(err);
        }
      });
    }
  }, {
    key: "addBlob",
    value: function addBlob() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("addBlob");
      var plainText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("addBlob");
      this.set(nameToSave, plainText.toString().trim());
      return this;
    }
    /**********************$$*****************************/

    /***#### KEYS CRYPTO ####***/

  }, {
    key: "asyncCreateSYMKey",
    value: function asyncCreateSYMKey(nameToSave) {
      var _this3 = this;

      var ivLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
      var keyLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
      return new Promise(function (resolve, reject) {
        try {
          resolve(_this3.createSYMKey(nameToSave, ivLength, keyLength));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * Creates hex-encoded SYM key, which is just some random hex-encoded bytes
     * @param nameToSave
     * @param keyLength
     * @returns {iCrypto}
     */

  }, {
    key: "createSYMKey",
    value: function createSYMKey() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("createSYMKey");
      var keyLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      var self = this;
      var key = iCrypto.getBytes(keyLength);
      self.set(nameToSave, lib["util"].bytesToHex(key));
      return self;
    }
    /**
     * Sets passed SYM key inside the object
     * @param nameToSave
     * @param {string} key Must be hexified string
     */

  }, {
    key: "setSYMKey",
    value: function setSYMKey() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("setSYMKey");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("setSYMKey");
      this.set(nameToSave, key);
      return this;
    }
    /**
     * Given a password and a salt computes SYM key and saves it under given name in base64 format
     * @param nameToSave
     * @param password
     * @param salt Must be previously sotre within the current iCrypto instance
     *        Must be hex-encoded
     * @param numIterations
     * @param keyLength
     */

  }, {
    key: "createPasswordBasedSymKey",
    value: function createPasswordBasedSymKey() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("createSYMKey");
      var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("createSYMKey");
      var salt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("createSYMKey");
      var numIterations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;
      var keyLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 32;
      var self = this;
      var sRaw = lib["util"].hexToBytes(this.get(salt));
      var key = lib["pkcs5"].pbkdf2(password, sRaw, numIterations, keyLength);
      var res = lib["util"].bytesToHex(key);
      self.set(nameToSave, res);
      return self;
    }
    /**
     * requires object of similar structure for key as being created by createSYMKey
     * @param target
     * @param key
     * @param nameToSave
     * @returns {Promise}
     */

  }, {
    key: "asyncAESEncrypt",
    value: function asyncAESEncrypt(target, key, nameToSave, hexify, mode, encoding) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this4.AESEncrypt(target, key, nameToSave, hexify, mode, encoding));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * Encrypts blob identified by "target" parameter.
     * Target must be set inside iCrypto object
     * IV is randomly generated and appended to the cipher blob
     * @param {string} target
     * @param {string} key
     * @param {string} nameToSave
     * @param {boolean} hexify - Specifies the encoding of the resulting cipher. Default: hex.
     * @param {string} mode - specifies AES mode. Default - CBC
     * @param {number} ivLength - specifies length of initialization vector
     *  The initialization vector of specified length will be generated and
     *  appended to the end of resulting cipher. IV blob will be encoded according to
     *  outputEncoding parameter, and its length will be last 3 bytes of the cipher string.
     *
     */

  }, {
    key: "AESEncrypt",
    value: function AESEncrypt() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("AESEncrypt");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("AESEncrypt");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("AESEncrypt");
      var hexify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'CBC';
      var encoding = arguments.length > 5 ? arguments[5] : undefined;
      var self = this;

      if (!self.aes.modes.includes(mode.toUpperCase())) {
        throw "AESencrypt: Invalid AES mode";
      }

      mode = "AES-" + mode.toUpperCase(); //Creating random 16 bytes IV

      var iv = iCrypto.getBytes(16);
      var AESkey = lib["util"].hexToBytes(self.get(key));
      var cipher = lib["cipher"].createCipher(mode, AESkey);
      cipher.start({
        iv: iv
      });
      cipher.update(lib["util"].createBuffer(this.get(target), encoding));
      cipher.finish();
      this.set(nameToSave, hexify ? lib["util"].bytesToHex(iv) + cipher.output.toHex() : iv + cipher.output);
      return this;
    }
  }, {
    key: "asyncAESDecrypt",
    value: function asyncAESDecrypt(target, key, nameToSave) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this5.AESDecrypt(target, key, nameToSave));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * Decrypts the blob loaded into iCrypto object and specified by targe parameter
     * Assumes that initialization vector is PREPENDED to the cipher text
     * and its length is 16 bytes
     *
     * @param {string} target - ciphertext within iCrypto object
     * @param {string} key - Symmetric AES key in form of hex string
     * @param {string} nameToSave
     * @param {boolean} dehexify
     * @param {string} mode AES mode
     * @param {string} encoding - resulting plain text encoding default (UTF8)
     */

  }, {
    key: "AESDecrypt",
    value: function AESDecrypt() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("AESDecrypt");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("AESDecrypt");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("AESDecrypt");
      var dehexify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var mode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "CBC";
      var encoding = arguments.length > 5 ? arguments[5] : undefined;
      var self = this;
      var cipherWOIV;

      if (!self.aes.modes.includes(mode.toUpperCase())) {
        throw "AESencrypt: Invalid AES mode";
      }

      mode = "AES-" + mode.toUpperCase();
      var cipher = self.get(target);
      var iv;

      if (dehexify) {
        iv = lib["util"].hexToBytes(cipher.substring(0, 32));
        cipherWOIV = lib["util"].hexToBytes(cipher.substr(32));
      } else {
        //Assuming cipher is a binary string
        cipherWOIV = cipher.substr(16);
        iv = cipher.substring(0, 16);
      }

      var AESkey = lib["util"].hexToBytes(this.get(key));
      var decipher = lib["cipher"].createDecipher(mode, AESkey);
      decipher.start({
        iv: iv
      });
      decipher.update(lib["util"].createBuffer(cipherWOIV));
      decipher.finish();
      this.set(nameToSave, decipher.output.toString('utf8'));
      return this;
    }
  }, {
    key: "asyncHash",
    value: function asyncHash(target, nameToSave) {
      var _this6 = this;

      var algorithm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sha256";
      return new Promise(function (resolve, reject) {
        try {
          resolve(_this6.hash(target, nameToSave, algorithm));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * This function meant to be used on large files
     * It is asynchronous, uses web workers,
     * and it calculates hash of a large file without loading it
     * fully into memory
     * @param file  -  value of an input of type file
     * @param nameToSave - name to store resulting hash
     * @param algorithm - sha256 is default
     */

  }, {
    key: "hashFileWorker",
    value: function hashFileWorker() {
      var _this7 = this;

      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("fileHashWorker file");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("fileHashWorker nameToSave");
      var algorithm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sha256";
      return new Promise(function (resolve, reject) {
        var self = _this7;

        if (Worker === undefined) {
          throw "Web workers are not supported in current environment";
        }

        var worker = new Worker("/js/iCryptoWorker.js");

        worker.onmessage = function (ev) {
          if (ev.data[0] === "success") {
            self.set(nameToSave, ev.data[1]);
            resolve(self);
            worker.terminate();
          } else {
            reject(ev.data[1]);
            worker.terminate();
          }
        };

        worker.postMessage(["hashFile", file]);
      });
    }
    /**
     * Initializes stream encryptor or decryptor
     *
     * Supported algorithm is chacha20 only
     * Single instance of a single stream cryptor can be used
     * only one time, one way, and only for a single stream.
     * Meaning you can take a single stream and encrypt it chunk by chunk,
     * but then, if you want to decrypt the stream,  you have to
     * re-initialize cryptor instance or use a new one,
     * otherwise the output will be meaningless.
     *
     * All the chunks must flow in sequence.
     *
     * !!!Important
     *
     * Encryption:
     * Stream cryptor handles initialization vector (iv)
     * by prepending them to cipher. So, to encrypt the data -
     * just pass the key and new iv will be created automatically
     * and prepended to the cipher
     *
     * Decryption:
     * On Decryption the algorithm ASSUMES that first 6 bytes of
     * the ciphertext is iv.
     * So, it will treat first 6 bytes as iv regardles of chunks,
     * and will begin decryption starting from byte 7
     *
     * @param {String} nameToSave - Stream cryptor will be saved inside iCrypto instance
     * @param {String} key String of bytes in hex - Symmetric key used to encrypt/decrypt data
     *  The algorithm requires key to be 32 bytes precisely
        Only first 32 bytes (after decoding hex) will be taken
     * @param {Boolean} isEncryptionMode - flag encryption mode - true
     * @param {String} algorithm Supports only chacha20 for now
     */

  }, {
    key: "initStreamCryptor",
    value: function initStreamCryptor() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("initStreamEncryptor");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("initStreamEncryptor");
      var isEncryptionMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var algorithm = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "chacha20";
      var self = this;
      var ivRaw, ivHex, keyRaw, cryptor, ivBuffer;
      var mode = "enc";
      keyRaw = iCrypto.hexDecode(key);

      if (keyRaw.length < 16) {
        throw "chacha20: invalid key size: " + keyRaw.length + " key length must be 32 bytes";
      }

      var keyBuffer = iCrypto.stringToArrayBuffer(keyRaw).slice(0, 32);

      if (isEncryptionMode) {
        ivRaw = iCrypto.getBytes(6);
        ivHex = iCrypto.hexEncode(ivRaw);
        ivBuffer = iCrypto.stringToArrayBuffer(ivRaw).slice(0, 12);
        cryptor = new jschacha20_default.a(new Uint8Array(keyBuffer), new Uint8Array(ivBuffer), 0);
      } else {
        mode = "dec";
        ivBuffer = new ArrayBuffer(0);
      }

      var res = new function () {
        var self = this;
        self.cryptor = cryptor;
        self.key = key;
        self.iv = ivHex;
        self.mode = mode;

        self.encryptionMode = function () {
          return self.mode === "enc";
        };

        self.decryptionMode = function () {
          return self.mode === "dec";
        };

        self.encrypt = function (input) {
          var blob = typeof input === "string" ? iCrypto.stringToArrayBuffer(input) : input;

          if (!(blob instanceof ArrayBuffer) && !(blob instanceof Uint8Array)) {
            throw "StreamCryptor encrypt: input type is invalid";
          }

          if (self.cryptor._byteCounter === 0) {
            //First check if counter is 0.
            //If so - it is a first encryption block and we need to prepend IV
            var encrypted = self.cryptor.encrypt(new Uint8Array(blob));
            return iCrypto.concatUint8Arrays(new Uint8Array(ivBuffer), encrypted);
          } else {
            //Just encrypting the blob
            return self.cryptor.encrypt(new Uint8Array(blob));
          }
        };

        self.decrypt = function (input) {
          var blob = typeof input === "string" ? iCrypto.stringToArrayBuffer(input) : input;

          if (!(blob instanceof ArrayBuffer)) {
            throw "StreamCryptor encrypt: input type is invalid";
          }

          if (self.cryptor === undefined) {
            //decryptor was not initialized yet because
            //Initalization vecotor (iv)was not yet obtained
            //IV assumed to be first 6 bytes prepended to cipher
            var currentIVLength = ivBuffer.byteLength;

            if (currentIVLength + blob.byteLength <= 12) {
              ivBuffer = iCrypto.concatArrayBuffers(ivBuffer, blob); //Still gathering iv, so returning empty array

              return new Uint8Array();
            } else {
              var remainingIVBytes = 12 - ivBuffer.byteLength;
              ivBuffer = iCrypto.concatArrayBuffers(ivBuffer, blob.slice(0, remainingIVBytes));
              self.iv = iCrypto.hexEncode(iCrypto.arrayBufferToString(ivBuffer));
              self.cryptor = new jschacha20_default.a(new Uint8Array(keyBuffer), new Uint8Array(ivBuffer), 0);
              var chunk = new Uint8Array(blob.slice(remainingIVBytes, blob.byteLength));
              return self.cryptor.decrypt(chunk);
            }
          } else {
            //Decrypto is initialized.
            // Just decrypting the blob and returning result
            return self.cryptor.decrypt(new Uint8Array(blob));
          }
        };
      }();
      self.set(nameToSave, res);
      return self;
    }
  }, {
    key: "streamCryptorGetIV",
    value: function streamCryptorGetIV() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("streamCryptorGetIV");
      var self = this;
      var cryptor = self.get(target);
      return cryptor.iv;
    }
  }, {
    key: "streamCryptorEncrypt",
    value: function streamCryptorEncrypt() {
      var cryptorID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("streamCryptorEncrypt");
      var blob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("streamCryptorEncrypt");
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "raw";
      var self = this;
      var input;
      var cryptor = self.get(cryptorID);

      if (!cryptor.encryptionMode()) {
        throw "streamCryptorEncrypt error: mode is invalid";
      }

      if (blob instanceof ArrayBuffer) {
        input = blob;
      } else if (blob instanceof Uint8Array) {
        input = blob.buffer;
      } else if (typeof blob === "string") {
        input = iCrypto.stringToArrayBuffer(blob);
      } else {
        throw "streamCryptorEncrypt: invalid format input";
      }

      if (encoding === undefined || encoding === "raw") {
        return cryptor.encrypt(input).buffer;
      } else {
        throw "NOT IMPLEMENTED";
      }
    }
  }, {
    key: "streamCryptorDecrypt",
    value: function streamCryptorDecrypt() {
      var cryptorID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("streamCryptorEncrypt");
      var blob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("streamCryptorEncrypt");
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "raw";
      var self = this;
      var cryptor = self.get(cryptorID);
      var input;

      if (!cryptor.decryptionMode()) {
        throw "streamCryptorEncrypt error: mode is invalid";
      }

      if (blob instanceof ArrayBuffer) {
        input = blob;
      } else if (blob instanceof Uint8Array) {
        input = blob.buffer;
      } else if (typeof blob === "string") {
        input = iCrypto.stringToArrayBuffer(blob);
      } else {
        throw "streamCryptorEncrypt: invalid format input";
      }

      if (encoding === undefined || encoding === "raw") {
        return cryptor.decrypt(input).buffer;
      } else {
        throw "NOT IMPLEMENTED";
      }
    }
    /**
     *
     * @param target
     * @param nameToSave
     * @param algorithm
     */

  }, {
    key: "hash",
    value: function hash() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("hash");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("hash");
      var algorithm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sha256";
      var self = this;
      var blob = self.get(target);

      if (typeof blob !== "string") {
        throw "hash: invalid target type: " + typeof blob + "  Target must be string.";
      }

      algorithm = algorithm.toLowerCase();
      var hash = lib["md"].hasOwnProperty(algorithm) ? lib["md"][algorithm].create() : this.throwError("Wrong hash algorithm");
      hash.update(blob);
      this.set(nameToSave, hash.digest().toHex());
      return self;
    }
  }, {
    key: "createHash",
    value: function createHash() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("createHash");
      var algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "sha256";
      console.log("Create hash called.");
      console.log("sjcl is ".concat(typeof sjcl));

      for (var _i = 0, _Object$keys = Object.keys(sjcl); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        console.log(key);
      }

      var hash = sjcl.hash.hasOwnProperty(algorithm) ? new sjcl.hash[algorithm]() : this.throwError("Wrong hash algorithm");
      this.set(nameToSave, hash);
      return this;
    }
    /**
     *
     * @param target
     * @param {} blob can be binary string or arrayBuffer
     * @returns {iCrypto}
     */

  }, {
    key: "updateHash",
    value: function updateHash() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("updateHash: target");
      var blob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("updateHash: blob");
      var self = this;
      var input;

      if (typeof blob === "string") {
        input = iCrypto.stringToArrayBuffer(blob);
      } else if (blob instanceof Uint8Array) {
        input = blob.buffer;
      } else if (blob instanceof ArrayBuffer) {
        input = blob;
      } else {
        throw "invalid input format!";
      }

      var hash = self.get(target);
      hash.update(sjcl.codec.arrayBuffer.toBits(input));
      return self;
    }
  }, {
    key: "digestHash",
    value: function digestHash() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("digestHash");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("digestHash");
      var hexify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var self = this;
      var hRes = self.get(target);
      var res = hexify ? sjcl.codec.hex.fromBits(hRes.finalize()) : sjcl.codec.arrayBuffer.fromBits(hRes.finalize());
      this.set(nameToSave, res);
      return self;
    }
  }, {
    key: "asyncGenerateRSAKeyPair",
    value: function asyncGenerateRSAKeyPair() {
      var _this8 = this;

      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("asyncGenerateRSAKeyPair");
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
      return new Promise(function (resolve, reject) {
        var self = _this8;
        lib["rsa"].generateKeyPair({
          bits: length,
          workers: -1
        }, function (err, pair) {
          if (err) reject(err);else {
            try {
              var pubKey = lib["pki"].publicKeyToPem(pair.publicKey);
              var privKey = lib["pki"].privateKeyToPem(pair.privateKey);
              self.set(nameToSave, {
                publicKey: pubKey,
                privateKey: privKey
              });
              resolve(_this8);
            } catch (err) {
              reject(err);
            }
          }
        });
      });
    }
    /**
     * Generates RSA key pair.
     * Key saved in PEM format
     * resulting object has publicKey, privateKey, keyType, length
     * @param nameToSave
     * @param length
     * @returns {iCrypto}
     */

  }, {
    key: "generateRSAKeyPair",
    value: function generateRSAKeyPair() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("generateRSAKeyPair");
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
      var self = this;
      var pair = lib["pki"].rsa.generateKeyPair({
        bits: length,
        e: 0x10001
      });
      var pubKey = lib["pki"].publicKeyToPem(pair.publicKey);
      var privKey = lib["pki"].privateKeyToPem(pair.privateKey);
      self.set(nameToSave, {
        publicKey: pubKey,
        privateKey: privKey
      });
      return self;
    }
    /**
     * Takes previously saved RSA private key in PEM format,
     * extracts its public key
     * and saves it in PEM format under the name specified
     * @param target
     * @param nameToSave
     * @returns {iCrypto}
     */

  }, {
    key: "publicFromPrivate",
    value: function publicFromPrivate() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("publicFromPrivate");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("publicFromPrivate");
      var forgePrivateKey = lib["pki"].privateKeyFromPem(this.get(target));
      this.set(nameToSave, lib["pki"].publicKeyToPem(forgePrivateKey));
      return this;
    }
    /**
     * Accepts as an input RSA key and saves it inside an object under the name specified.
     * Key must be provided either in PEM or in raw base64.
     * @param {String} nameToSave
     * @param {String} keyData: public or private RSA key either in raw base64 or PEM format
     * @param {String} type: must be either "public" or "private"
     *
     * @returns {iCrypto}
     */

  }, {
    key: "setRSAKey",
    value: function setRSAKey() {
      var nameToSave = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("setRSAPublicKey");
      var keyData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("setRSAPublicKey");
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("setRSAPublicKey");

      if (type !== "public" && type !== "private") {
        throw "Invalid key type";
      }

      if (!iCrypto.isRSAPEMValid(keyData, type)) {
        keyData = iCrypto.base64ToPEM(keyData, type);
      }

      type === "public" ? lib["pki"].publicKeyFromPem(keyData) : lib["pki"].privateKeyFromPem(keyData);
      this.set(nameToSave, keyData);
      return this;
    }
    /**
     * For internal use only. Takes key data in form of a string
     * and checks whether it matches RSA PEM key format
     * @param {string} keyData
     * @param {string}type ENUM "public", "private"
     * @returns {boolean}
     */

  }, {
    key: "asyncPublicKeyEncrypt",
    value: function asyncPublicKeyEncrypt(target, keyPair, nameToSave, encoding) {
      var _this9 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this9.publicKeyEncrypt(target, keyPair, nameToSave));
        } catch (err) {
          reject(err);
        }
      });
    }
    /**
     * creates and saves public key fingerprint
     * @param target - public key, either keypair or public key
     * @param nameToSave
     * @param hashAlgorithm
     * @returns {iCrypto}
     */

  }, {
    key: "getPublicKeyFingerprint",
    value: function getPublicKeyFingerprint() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("getPublicKeyFingerpint");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("getPublicKeyFingerpint");
      var hashAlgorithm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sha256";
      var key = this.validateExtractRSAKey(this.get(target), "public");
      var forgeKey = lib["pki"].publicKeyFromPem(key);
      var fingerprint = lib["pki"].getPublicKeyFingerprint(forgeKey, {
        encoding: 'hex',
        md: lib["md"][hashAlgorithm].create()
      });
      this.set(nameToSave, fingerprint);
      return this;
    }
  }, {
    key: "publicKeyEncrypt",
    value: function publicKeyEncrypt() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("publicKeyEncrypt");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("publicKeyEncrypt");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("publicKeyEncrypt");
      var encoding = arguments.length > 3 ? arguments[3] : undefined;
      key = this.validateExtractRSAKey(this.get(key), "public");
      var publicKey = lib["pki"].publicKeyFromPem(key);
      var result = publicKey.encrypt(this.get(target));

      if (encoding) {
        result = this._encodeBlob(result, encoding);
      }

      this.set(nameToSave, result);
      return this;
    }
    /**
     * For internal use. Encode the blob in format specified
     * @param blob
     * @param encoding
     * @private
     */

  }, {
    key: "_encodeBlob",
    value: function _encodeBlob() {
      var blob = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("_encodeBlob");
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("_encodeBlob");
      var self = this;

      if (!this.encoders.hasOwnProperty(encoding)) {
        throw "_encodeBlob: Invalid encoding: " + encoding;
      }

      return self.encoders[encoding](blob);
    }
  }, {
    key: "_decodeBlob",
    value: function _decodeBlob() {
      var blob = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("_encodeBlob");
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("_encodeBlob");
      var self = this;

      if (!this.encoders.hasOwnProperty(encoding)) {
        throw "_decodeBlob: Invalid encoding: " + encoding;
      }

      return this.decoders[encoding](blob);
    }
  }, {
    key: "asyncPrivateKeyDecrypt",
    value: function asyncPrivateKeyDecrypt(target, key, nameToSave) {
      var _this10 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this10.privateKeyDecrypt(target, key, nameToSave));
        } catch (err) {
          reject(err);
        }
      });
    }
  }, {
    key: "privateKeyDecrypt",
    value: function privateKeyDecrypt() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("privateKeyDecrypt");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("privateKeyDecrypt");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("privateKeyDecrypt");
      var encoding = arguments.length > 3 ? arguments[3] : undefined;
      key = this.validateExtractRSAKey(this.get(key), "private");
      var privateKey = lib["pki"].privateKeyFromPem(key);
      var cipher = this.get(target);

      if (encoding) {
        cipher = this._decodeBlob(cipher, encoding);
      }

      this.set(nameToSave, privateKey.decrypt(cipher));
      return this;
    }
  }, {
    key: "asyncPrivateKeySign",
    value: function asyncPrivateKeySign(target, keyPair, nameToSave) {
      var _this11 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this11.privateKeySign(target, keyPair, nameToSave));
        } catch (err) {
          reject(err);
        }
      });
    }
  }, {
    key: "privateKeySign",
    value: function privateKeySign() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("privateKeyEncrypt");
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("privateKeyEncrypt");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("privateKeyEncrypt");
      var hashAlgorithm = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "sha256";
      var hexifySign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      key = this.validateExtractRSAKey(this.get(key), "private");
      var privateKey = lib["pki"].privateKeyFromPem(key);
      var md = lib["md"][hashAlgorithm].create();
      md.update(this.get(target));
      var signature = privateKey.sign(md);
      signature = hexifySign ? lib["util"].bytesToHex(signature) : signature;
      this.set(nameToSave, signature);
      return this;
    }
  }, {
    key: "asyncPublicKeyVerify",
    value: function asyncPublicKeyVerify(target, signature, key, nameToSave) {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        try {
          resolve(_this12.publicKeyVerify(target, signature, key, nameToSave));
        } catch (err) {
          reject(err);
        }
      });
    }
  }, {
    key: "publicKeyVerify",
    value: function publicKeyVerify() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("publicKeyVerify");
      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("publicKeyVerify");
      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("publicKeyVerify");
      var nameToSave = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : iCrypto.pRequired("publicKeyVerify");
      var dehexifySignRequired = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      key = this.validateExtractRSAKey(this.get(key), "public");
      var publicKey = lib["pki"].publicKeyFromPem(key);
      var md = lib["md"].sha256.create();
      md.update(this.get(target));
      var sign = this.get(signature);
      sign = dehexifySignRequired ? lib["util"].hexToBytes(sign) : sign;
      var verified = publicKey.verify(md.digest().bytes(), sign);
      this.set(nameToSave, verified);
      return this;
    }
    /**
     * Validates and extracts RSA key from either keypair
     * or separate private or public keys saved previously within the object.
     * Checks PEM structure and returns requested key in PEM format
     * or throws error if something wrong
     * @param key - target key
     * @param type - "public" or "private"
     * @return public or private key in PEM format
     */

  }, {
    key: "validateExtractRSAKey",
    value: function validateExtractRSAKey() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("validateAndExtractRSAKey");
      var keyType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("validateAndExtractRSAKey");
      var keyTypes = {
        public: "publicKey",
        private: "privateKey"
      };
      if (!Object.keys(keyTypes).includes(keyType)) throw "validateExtractRSAKey: key type is invalid!";

      if (key[keyTypes[keyType]]) {
        key = key[keyTypes[keyType]];
      }

      if (!iCrypto.isRSAPEMValid(key, keyType)) {
        console.log(keyType);
        console.log(key);
        throw "validateExtractRSAKey: Invalid key format";
      }

      return key;
    }
  }, {
    key: "pemToBase64",
    value: function pemToBase64() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("pemToBase64");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("pemToBase64");
      var keyType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("pemToBase64");
      var key = this.get(target);

      if (!iCrypto.isRSAPEMValid(key, keyType)) {
        console.log(keyType);
        console.log(key);
        throw "validateExtractRSAKey: Invalid key format";
      }

      key = key.trim().split(/\r?\n/).slice(1, -1).join("");
      this.set(nameToSave, key);
    }
    /***#### COMPRESSION ####***/

  }, {
    key: "asyncCompress",
    value: function asyncCompress(target, nameToSave) {} // return new Promise((resolve, reject)=>{
    //     try{
    //         resolve(this.compress(target, nameToSave));
    //     } catch(err){
    //         reject(err);
    //     }
    // })

    /**
     * Compresses data under key name
     * @param target
     *  type: String
     *  Key to data that needed to be compressed
     * @param nameToSave
     *  type: String
     *  if passed - function will save the result of compression under this key
     *  otherwise the compression will happen in-place
     */

  }, {
    key: "compress",
    value: function compress() {//let compressed = LZMA.compress(this.get(target));
      // this.set(nameToSave, compressed);
      // return this;

      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("compress");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("compress");
    }
  }, {
    key: "asyncDecompress",
    value: function asyncDecompress(target, nameToSave) {} // return new Promise((resolve, reject)=>{
    //     try{
    //         resolve(this.decompress(target, nameToSave));
    //     } catch(err){
    //         reject(err);
    //     }
    //
    // })

    /**
     * Decompresses data under key name
     * @param target
     *  type: String
     *  Key to data that needed to be compressed
     * @param nameToSave
     *  type: String
     *  if passed - function will save the result of compression under this key
     *  otherwise decompression will happen in-place
     */

  }, {
    key: "decompress",
    value: function decompress() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("decompress");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("decompress");
    } // let decompressed = LZMA.decompress(this.get(target));
    // this.set(nameToSave, decompressed);
    // return this;

    /***#### UTILS ####***/

  }, {
    key: "encode",
    value: function encode() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("encode");
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("encode");
      var nameToSave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("encode");
      var self = this;
      self.set(nameToSave, self._encodeBlob(this.get(target), encoding));
      return this;
    }
  }, {
    key: "base64Encode",
    value: function base64Encode() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("base64Encode");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("base64Encode");
      var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var target = stringify ? JSON.stringify(this.get(name)) : this.get(name);
      this.set(nameToSave, iCrypto.base64Encode(target));
      return this;
    }
  }, {
    key: "base64Decode",
    value: function base64Decode() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("base64decode");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("base64decode");
      var jsonParse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var decoded = iCrypto.base64Decode(this.get(name));
      decoded = jsonParse ? JSON.parse(decoded) : decoded;
      this.set(nameToSave, decoded);
      return this;
    }
    /*
        base32Encode(name = this.pRequired("base32Encode"),
                     nameToSave = this.pRequired("base32Encode")){
            let base32 = new Base32();
            let encoded = base32.encode(this.get(name));
            this.set(nameToSave, encoded);
            return this;
        }
          base32Decode(name = this.pRequired("base64decode"),
                     nameToSave = this.pRequired("base64decode")){
            let base32 = new Base32();
            let decoded = base32.decode(this.get(name));
            this.set(nameToSave, decoded);
            return this;
        }
    /**/

  }, {
    key: "bytesToHex",
    value: function bytesToHex() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("bytesToHex");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("bytesToHex");
      var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var target = stringify ? JSON.stringify(this.get(name)) : this.get(name);
      this.set(nameToSave, iCrypto.hexEncode(target));
      return this;
    }
  }, {
    key: "hexToBytes",
    value: function hexToBytes() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("hexToBytes");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("hexToBytes");
      var jsonParse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var decoded = iCrypto.hexDecode(this.get(name));
      decoded = jsonParse ? JSON.parse(decoded) : decoded;
      this.set(nameToSave, decoded);
      return this;
    }
  }, {
    key: "stringifyJSON",
    value: function stringifyJSON() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("stringify");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("stringify");
      var target = this.get(name);

      if (typeof target !== "object") {
        throw "stringifyJSON: target invalid";
      }

      this.set(nameToSave, JSON.stringify(target));
      return this;
    }
  }, {
    key: "parseJSON",
    value: function parseJSON() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("stringify");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("stringify");
      var target = this.get(name);

      if (typeof target !== "string") {
        throw "stringifyJSON: target invalid";
      }

      this.set(nameToSave, JSON.parse(target));
      return this;
    }
    /**
     * Merges elements into a single string
     * if name passed - saves the merge result inside the object
     * under key <name>.
     * @param things
     *     type: array
     *     array of strings. Each string is a key.
     * @param name
     *     type: string
     *     name of the key under which to save the merge result
     */

  }, {
    key: "merge",
    value: function merge() {
      var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("merge");
      var nameToSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("merge");
      if (!this.keysExist(things)) throw "merge: some or all objects with such keys not found ";
      var result = "";

      for (var i = 0; i < things.length; ++i) {
        var candidate = this.get(things[i]);
        if (typeof candidate === "string" || typeof candidate === "number") result += candidate;else throw "Object " + things[i] + " is not mergeable";
      }

      this.set(nameToSave, result);
      return this;
    }
  }, {
    key: "encodeBlobLength",
    value: function encodeBlobLength() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iCrypto.pRequired("encodeBlobLength");
      var targetLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : iCrypto.pRequired("encodeBlobLength");
      var paddingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : iCrypto.pRequired("encodeBlobLength");
      var nameToSave = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : iCrypto.pRequired("encodeBlobLength");

      if (typeof paddingChar !== "string") {
        throw "encodeBlobLength: Invalid padding char";
      }

      var l = String(this.get(target).length);
      var paddingLength = targetLength - l.length;

      if (paddingLength < 0) {
        throw "encodeBlobLength: String length exceedes target length";
      }

      var padding = paddingChar[0].repeat(paddingLength);
      this.set(nameToSave, padding + l);
      return this;
    }
    /************SERVICE FUNCTIONS**************/

  }, {
    key: "get",
    value: function get(name) {
      if (this.keysExist(name)) return this.store[name];
      throw "Property " + name + " not found";
    }
  }, {
    key: "set",
    value: function set(name, value) {
      if (this.locked) throw "Cannot add property: object locked";
      this.assertKeysAvailable(name);
      this.store[name] = value;
    }
  }, {
    key: "lock",
    value: function lock() {
      this.locked = true;
    }
  }, {
    key: "unlock",
    value: function unlock() {
      this.locked = false;
    }
  }, {
    key: "assertKeysAvailable",
    value: function assertKeysAvailable(keys) {
      if (this.keysExist(keys)) throw "Cannot add property: " + keys.toString() + " property with such name already exists";
    }
  }, {
    key: "keysExist",
    value: function keysExist(keys) {
      if (!keys) throw "keysExist: Missing required arguments";
      if (typeof keys === "string" || typeof keys === "number") return this._keyExists(keys);
      if (typeof keys !== "object") throw "keysExist: unsupported type";
      if (keys.length < 1) throw "array must have at least one key";
      var currentKeys = Object.keys(this.store);

      for (var i = 0; i < keys.length; ++i) {
        if (!currentKeys.includes(keys[i].toString())) return false;
      }

      return true;
    }
  }, {
    key: "_keyExists",
    value: function _keyExists(key) {
      if (!key) throw "keyExists: Missing required arguments";
      return Object.keys(this.store).includes(key.toString());
    }
  }, {
    key: "throwError",
    value: function throwError() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unknown error";
      throw message;
    }
  }], [{
    key: "isRSAPEMValid",
    value: function isRSAPEMValid(keyData, type) {
      keyData = keyData.trim();
      var headerPattern = type === "public" ? /^-{4,5}BEGIN.*PUBLIC.*KEY.*-{4,5}/ : /^-{4,5}BEGIN.*PRIVATE.*KEY.*-{4,5}/;
      var footerPattern = type === "public" ? /^-{4,5}END.*PUBLIC.*KEY.*-{4,5}/ : /^-{4,5}END.*PRIVATE.*KEY.*-{4,5}/;
      var valid = true;
      keyData = keyData.replace(/\r?\n$/, "");
      var keyDataArr = keyData.split(/\r?\n/);
      valid = valid && keyDataArr.length > 2 && headerPattern.test(keyDataArr[0]) && footerPattern.test(keyDataArr[keyDataArr.length - 1]);
      return valid;
    }
  }, {
    key: "base64ToPEM",
    value: function base64ToPEM(keyData, type) {
      var header = type === "public" ? "-----BEGIN PUBLIC KEY-----" : "-----BEGIN RSA PRIVATE KEY-----";
      var footer = type === "public" ? "-----END PUBLIC KEY-----" : "-----END RSA PRIVATE KEY-----";
      var result = header;

      for (var i = 0; i < keyData.length; ++i) {
        result += i % 64 === 0 ? "\r\n" + keyData[i] : keyData[i];
      }

      result += "\r\n" + footer;
      return result;
    }
  }, {
    key: "arrayBufferToString",
    value: function arrayBufferToString(buf) {
      return String.fromCharCode.apply(null, new Uint16Array(buf));
    }
  }, {
    key: "stringToArrayBuffer",
    value: function stringToArrayBuffer(str) {
      var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char

      var bufView = new Uint16Array(buf);

      for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }

      return buf;
    }
    /**
     * TODO make it universal and for arbitrary number of arrays     *
     * @param arr1
     * @param arr2
     * @returns {Uint8Array}
     */

  }, {
    key: "concatUint8Arrays",
    value: function concatUint8Arrays(arr1, arr2) {
      var res = new Uint8Array(arr1.byteLength + arr2.byteLength);
      res.set(arr1, 0);
      res.set(arr2, arr1.byteLength);
      return res;
    }
    /**
     * Concatinates 2 array buffers in order buffer1 + buffer2
     * @param {ArrayBuffer} buffer1
     * @param {ArrayBuffer} buffer2
     * @returns {ArrayBufferLike}
     */

  }, {
    key: "concatArrayBuffers",
    value: function concatArrayBuffers(buffer1, buffer2) {
      var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
      tmp.set(new Uint8Array(buffer1), 0);
      tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
      return tmp.buffer;
    }
  }, {
    key: "getBytes",
    value: function getBytes(length) {
      return lib["random"].getBytesSync(length);
    }
  }, {
    key: "hexEncode",
    value: function hexEncode(blob) {
      return lib["util"].bytesToHex(blob);
    }
  }, {
    key: "hexDecode",
    value: function hexDecode(blob) {
      return lib["util"].hexToBytes(blob);
    }
  }, {
    key: "base64Encode",
    value: function base64Encode(blob) {
      return lib["util"].encode64(blob);
    }
  }, {
    key: "base64Decode",
    value: function base64Decode(blob) {
      return lib["util"].decode64(blob);
    }
    /**
     * Returns random integer
     * @param a
     * @param b
     */

  }, {
    key: "randInt",
    value: function randInt(min, max) {
      if (max === undefined) {
        max = min;
        min = 0;
      }

      if (typeof min !== 'number' || typeof max !== 'number') {
        throw new TypeError('Expected all arguments to be numbers');
      }

      return Math.floor(Math.random() * (max - min + 1) + min);
    }
  }, {
    key: "createRandomHexString",
    value: function createRandomHexString(length) {
      var bytes = iCrypto.getBytes(length);
      var hex = iCrypto.hexEncode(bytes);
      var offset = iCrypto.randInt(0, hex.length - length);
      return hex.substring(offset, offset + length);
    }
  }, {
    key: "pRequired",
    value: function pRequired() {
      var functionName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "iCrypto function";
      throw functionName + ": missing required parameter!";
    }
  }]);

  return iCrypto;
}();
// CONCATENATED MODULE: ./common/IError.js


var IError_IError =
/*#__PURE__*/
function () {
  function IError() {
    classCallCheck_default()(this, IError);
  }

  createClass_default()(IError, null, [{
    key: "required",
    value: function required(msg) {
      if (!msg) {
        msg = "Missing required parameter";
      }

      throw new Error(msg);
    }
  }]);

  return IError;
}();
// CONCATENATED MODULE: ./client/src/js/lib/Topic.js


var Topic_Topic =
/*#__PURE__*/
function () {
  function Topic(pkfp, name, key, comment) {
    classCallCheck_default()(this, Topic);

    this.pkfp = pkfp;
    this.name = name;
    this.key = key;
    this.comment = comment;
  }

  createClass_default()(Topic, [{
    key: "setName",
    value: function setName(name) {
      this.name = name;
    }
  }]);

  return Topic;
}();
// CONCATENATED MODULE: ./client/src/js/lib/Vault.js







/**
 * Represents key vault
 *
 *
 */

var Vault_Vault =
/*#__PURE__*/
function () {
  function Vault() {
    classCallCheck_default()(this, Vault);

    this.initialized = false;
    this.admin = null;
    this.adminKey = null;
    this.topics = {};
    this.password = null;
    this.publicKey = null;
    this.privateKey = null;
  }
  /**
   * Given a password creates an empty vault
   * with generated update private key inside
   * @param password
   * @returns {Vault}
   */


  createClass_default()(Vault, [{
    key: "init",
    value: function init(password) {
      if (!password || password.trim === "") {
        throw "Password required";
      } //CHECK password strength and reject if not strong enough


      var ic = new iCrypto_iCrypto();
      ic.generateRSAKeyPair("kp"); //Create new Vault object

      this.password = password;
      this.topics = {};
      this.privateKey = ic.get("kp").privateKey;
      this.publicKey = ic.get("kp").publicKey;
      this.initialized = true;
    }
    /**
     * Given a password and a key
     * initializes a vault, creates update key
     * sets it to admin vault and sets admin private key
     *
     * @param password
     * @param adminKey
     * @returns {Vault}
     */

  }, {
    key: "initAdmin",
    value: function initAdmin(password, adminKey) {
      this.init(password);
      this.admin = true;
      this.adminKey = adminKey;
    }
  }, {
    key: "initSaved",
    value: function initSaved() {
      var _this = this;

      var vault_encrypted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IError_IError.required("Vault parse: data parameter missing");
      var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IError_IError.required("Vault parse: password parameter missing");
      var ic = new iCrypto_iCrypto();
      ic.addBlob("s16", vault_encrypted.substring(0, 256)).addBlob("v_cip", vault_encrypted.substr(256)).hexToBytes("s16", "salt").createPasswordBasedSymKey("sym", password, "s16").AESDecrypt("v_cip", "sym", "vault_raw", true); //Populating new object

      var data = JSON.parse(ic.get("vault_raw"));
      this.adminKey = data.adminKey;
      this.admin = data.admin;
      this.publicKey = data.publicKey;
      this.privateKey = data.privateKey;
      this.password = password;
      Object.keys(data.topics).forEach(function (k, v) {
        _this.topics[k] = new Topic_Topic(k, data.topics[k].name, data.topics[k].key, data.topics[k].comment);
      });
      this.initialized = true;
    } //This has to be moved outside

  }, {
    key: "save",
    value: function save() {
      if (!this.password || this.privateKey || this.topics) {
        throw "Vault object structure is not valid";
      } //Check if vault exists decrypted and loaded
      //If not
      // Throw error
      //Encrypt vault data with given password


      var vault = JSON.stringify({
        privateKey: this.privateKey,
        topics: JSON.parse(JSON.stringify(this.topics))
      });
      var ic = new iCrypto_iCrypto();
      ic.createNonce("salt", 128).base64Encode("salt", "s64").createPasswordBasedSymKey("key", this.password, "s64").addBlob("vault", vault).AESEncrypt("vault", "key", "cipher").base64Encode("cipher", "cip64").merge(["cip64", "s64"], "res").setRSAKey("asymkey", this.privateKey, "private").privateKeySign("res", "asymkey", "sign"); //Sign encrypted vault with private key

      var body = {
        vault: ic.get("res"),
        sign: ic.get("sign")
      };
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "/update", true);
      xhr.setRequestHeader('Content-Type', 'application/json');

      xhr.onreadystatechange = function () {
        console.log("Server said that vault is saved!");
      };

      xhr.send(body); //Send vault to the server
      //Display result of save request
    }
  }, {
    key: "changePassword",
    value: function changePassword(newPassword) {
      if (!this.initialized) {
        throw "The vault hasn't been initialized";
      }

      if (!newPassword || newPassword.trim === "") {
        throw "Password required";
      }

      this.password = newPassword;
    }
    /**
     * Stringifies and encrypts this object
     */

  }, {
    key: "pack",
    value: function pack() {
      if (!this.initialized) {
        throw "The vault hasn't been initialized";
      }

      var res = JSON.stringify({
        topics: this.topics,
        publicKey: this.publicKey,
        privateKey: this.privateKey,
        admin: this.admin,
        adminKey: this.adminKey
      });
      console.log(this.topics);
      var ic = new iCrypto_iCrypto();
      ic.createNonce("salt", 128).bytesToHex("salt", "s16").createPasswordBasedSymKey("key", this.password, "s16").addBlob("vault", res).AESEncrypt("vault", "key", "v_cip", true, "CBC", "utf8").merge(["s16", "v_cip"], "reshex").setRSAKey("priv", this.privateKey, "private").hexToBytes("reshex", "res").privateKeySign("res", "priv", "sign");
      return {
        vault: ic.get("reshex"),
        sign: ic.get("sign")
      };
    }
  }, {
    key: "addTopic",
    value: function addTopic(pkfp, name, privateKey, comment) {
      if (this.topics.hasOwnProperty(pkfp)) throw "Topic with such id already exists";
      this.topics[pkfp] = new Topic_Topic(pkfp, name, privateKey, comment);
    }
  }, {
    key: "removeTopic",
    value: function removeTopic() {}
  }]);

  return Vault;
}(); // a = {
//
//
//     encrypted: "some-bytes",
//
//     privateKey: "key",
//     publicKey: "key",
//     password: passwordRaw
//
//     topics: {
//         topicName1: {
//             key: "key",
//             comment: "comment"
//         },
//         topicName2: {
//             key: "key",
//             comment: "comment"
//         }
//
//         //...
//     }
//
// };
// EXTERNAL MODULE: ./node_modules/cute-set/index.js
var cute_set = __webpack_require__(191);

// CONCATENATED MODULE: ./client/src/js/lib/dom-util.js





/**
 *
 *
 * Bakes DOM element as per request in data
 *
 * @param name - name of the element such as div, button etc
 * recipe is a JSON object with following properties:
 *  * id - string id
 *  * classes - list of classes. Array or single entry
 *  * attributes - object of attributes key vaule pairs
 *  * html - inner html
 *  * text - inner text
 *  * val  - value
 *  
 *  
 * @param recipe
 */
function bake(name, recipe) {
  var el = document.createElement(name);
  if (!recipe) return el;

  if (recipe.classes) {
    if (typeof recipe.classes === "object") {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = recipe.classes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var c = _step.value;
          el.classList.add(c);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (typeof recipe.classes === "string") {
      el.classList.add(recipe.classes);
    } else {
      throw "Bake parameters invalid";
    }
  }

  if (recipe.listeners) {
    for (var _i = 0, _Object$keys = Object.keys(recipe.listeners); _i < _Object$keys.length; _i++) {
      var ev = _Object$keys[_i];
      el.addEventListener(ev, recipe.listeners[ev]);
    }
  }

  if (recipe.id) {
    el.setAttribute("id", recipe.id);
  }

  if (recipe.attributes) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(recipe.attributes); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      el.setAttribute(key, recipe.attributes[key]);
    }
  }

  if (recipe.html) el.innerHTML = recipe.html;
  if (recipe.text) el.innerText = recipe.text;
  if (recipe.val) el.value = recipe.val;
  return el;
}
function appendChildren(parent, children) {
  if (children instanceof Array) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var child = _step2.value;
        parent.appendChild(child);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } else {
    parent.appendChild(children);
  }
}
function dom_util_$(selector) {
  return document.querySelector(selector);
}
function $$(selector) {
  return document.querySelectorAll(selector);
}
function displayNone(selector) {
  dom_util_$(selector).style.display = "none";
}
function displayBlock(selector) {
  dom_util_$(selector).style.display = "block";
}
function displayFlex(selector) {
  dom_util_$(selector).style.display = "flex";
}
// CONCATENATED MODULE: ./client/src/js/lib/dropdown.js



function dropdown_reset() {
  document.querySelectorAll(".menu-dropdown").forEach(function (el) {
    el.addEventListener("click", function () {
      console.log("Dropdown menu clicked!");
    });
  });
}
/**
 * Creates button-based dropdown menu
 * Menu items will be unordered list
 * @param menuTitle - string this will appear on the button
 * @param items
 */

function bakeDropdownMenu(menuTitle, items) {
  var dropdownContainer = bake("div", {
    classes: ["dropdown-wrap"]
  });
  var button = bake("button", {
    classes: "dropdown-button",
    text: menuTitle
  });
  var menuOptions = bake("ul", {
    classes: "dropdown"
  });
  Object.keys(items).forEach(function (key) {
    var option = bake("li", {
      classes: "dropdown-item",
      text: key
    });
    option.addEventListener("click", function (ev) {
      items[key](ev);
    });
    menuOptions.appendChild(option);
  });
  appendChildren(dropdownContainer, [button, menuOptions]);
  return dropdownContainer;
}
// CONCATENATED MODULE: ./client/src/js/lib/editable_field.js

function bakeEditableField(placeholder, userClasses) {
  var classes = ["editable-field"];

  if (userClasses !== undefined) {
    classes = classes.concat(userClasses);
  }

  return bake("input", {
    classes: classes,
    attributes: {
      type: "text",
      placeholder: placeholder ? placeholder : ""
    }
  });
}
// CONCATENATED MODULE: ./client/src/js/chat/ChatUtility.js



var ChatUtility_ChatUtility =
/*#__PURE__*/
function () {
  function ChatUtility() {
    classCallCheck_default()(this, ChatUtility);
  }

  createClass_default()(ChatUtility, null, [{
    key: "decryptStandardMessage",

    /**
     * Standard message referred to string of form [payload] + [sym key cipher] + [const length sym key length encoded]
     * All messages in the system encrypted and decrypted in the described way except for chat messages files and streams.
     * Sym key generated randomly every time
     * @param blob - cipher blob
     * @param lengthSymLengthEncoded number of digits used to encode length of the sym key
     * @param privateKey
     * @returns {}
     */
    value: function decryptStandardMessage() {
      var blob = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Err.required();
      var privateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Err.required();
      var lengthSymLengthEncoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var symKeyLength = parseInt(blob.substr(blob.length - lengthSymLengthEncoded));
      var symKeyCipher = blob.substring(blob.length - lengthSymLengthEncoded - symKeyLength, blob.length - lengthSymLengthEncoded);
      var payloadCipher = blob.substring(0, blob.length - lengthSymLengthEncoded - symKeyLength);
      var ic = new iCrypto_iCrypto();
      ic.addBlob("blobcip", payloadCipher).addBlob("symkcip", symKeyCipher).asym.setKey("privk", privateKey, "private").privateKeyDecrypt("symkcip", "privk", "symk", "hex").AESDecrypt("blobcip", "symk", "blob-raw", true, "CBC", "utf8");
      return ic.get("blob-raw");
    }
  }, {
    key: "encryptStandardMessage",
    value: function encryptStandardMessage() {
      var blob = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Err.required();
      var publicKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Err.required();
      var lengthSymLengthEncoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var ic = new iCrypto_iCrypto();
      ic.sym.createKey("symk").addBlob("payload", blob).asym.setKey("pubk", publicKey, "public").AESEncrypt("payload", "symk", "blobcip", true, "CBC", "utf8").asym.encrypt("symk", "pubk", "symcip", "hex").encodeBlobLength("symcip", lengthSymLengthEncoded, "0", "symciplength").merge(["blobcip", "symcip", "symciplength"], "res");
      return ic.get("res");
    }
  }, {
    key: "publicKeyEncrypt",
    value: function publicKeyEncrypt() {
      var blob = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Err.required();
      var publicKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Err.required();
      var ic = new iCrypto_iCrypto();
      ic.addBlob("blob", blob).asym.setKey("pubk", publicKey, "public").publicKeyEncrypt("blob", "pubk", "blobcip", "hex");
      return ic.get("blobcip");
    }
  }, {
    key: "privateKeyDecrypt",
    value: function privateKeyDecrypt(blob, privateKey) {
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "hex";
      var ic = new iCrypto_iCrypto();
      ic.addBlob("blobcip", blob).asym.setKey("priv", privateKey, "private").privateKeyDecrypt("blobcip", "priv", "blob", encoding);
      return ic.get("blob");
    }
  }, {
    key: "symKeyEncrypt",
    value: function symKeyEncrypt(blob, key) {
      var hexify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var ic = new iCrypto_iCrypto();
      ic.addBlob("b", blob).sym.setKey("sym", key).AESEncrypt("b", "sym", "cip", hexify, "CBC", "utf8");
      return ic.get("cip");
    }
  }, {
    key: "symKeyDecrypt",
    value: function symKeyDecrypt(cip, key) {
      var dehexify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var ic = new iCrypto_iCrypto();
      ic.addBlob("cip", cip).sym.setKey("sym", key).AESDecrypt("cip", "sym", "b", dehexify, "CBC", "utf8");
      return ic.get("b");
    }
  }]);

  return ChatUtility;
}();
// CONCATENATED MODULE: ./client/src/js/lib/PasswordVerify.js
function verifyPassword(password, confirm) {
  if (!password || !password.trim() || !/^[a-zA-Z0-9!@#$%^&*]{9,}$/.test(password)) {
    return "Password or passphrase must be at least 9 characters long and can contain only lowercase a-z, uppercase A-Z and symbols !@#$%^&*";
  }

  if (password !== confirm) {
    return "Password and confirmation do not match.";
  }
}
// CONCATENATED MODULE: ./client/src/js/admin.js












window.toastr = toastr;









window.iCrypto = iCrypto_iCrypto;
var admin_adminSession;
var filterFieldSelector;
var logTableBody;
/**
 * Closure for processing admin requests while admin logged in
 * Initialized when admin logs in
 * @data - Object with request data
 * @onSuccess - success handler
 * @onError - error handler
 */

var processAdminRequest = function processAdminRequest() {
  throw "Admin session uninitialized";
};

document.addEventListener('DOMContentLoaded', function (event) {
  document.title = "Islands | Admin login";
  dom_util_$("main").classList.add("main-admin");
  dom_util_$("header").style.minWidth = "111rem";

  if (!secured) {
    dom_util_$('#island-setup').addEventListener("click", setupIslandAdmin);
    dom_util_$("#setup--wrapper").addEventListener("keyup", function (ev) {
      if (ev.which === 13 || ev.keyCode === 13) {
        setupIslandAdmin();
      }
    });
    displayFlex('#setup--wrapper');
    return;
  }

  $('#admin-login').click(adminLogin);
  dom_util_$("#admin-login--wrapper").addEventListener("keyup", function (ev) {
    if (ev.which === 13 || ev.keyCode === 13) {
      adminLogin();
    }
  });
  $('#run-update').click(launchUpdate);
  $('#download-logs').click(function () {
    loadLogs(false, true);
  });
  $('#add-admin-service').click(addAdminHiddenService);
  $('#add-guest-service').click(createGuest);
  $('#update-from-file').click(switchUpdateMode);
  $('#update-from-git').click(switchUpdateMode);
  $('#to-chat').click(returnToChat);
  $('#admin-logout-button').click(adminLogout);
  $('#clear-logs').click(clearLogs);
  $('#update-file').change(processUpdateFile);
  $('#admin-login--wrapper').css('display', "flex");
  $('#setup--wrapper').hide();
  $('#login-setup--wrapper').css('display', "block");
  $('.update-option').each(function (index, el) {
    $(el).click(switchUpdateOption);
  });
  logTableBody = document.querySelector("#log-content").lastElementChild;
  filterFieldSelector = document.querySelector('#filter-field-selector');
  filterFieldSelector.addEventListener("change", filterLogs);
  document.querySelector("#log-filter").addEventListener("keyup", filterLogs);
  $('#log-reverse').click(reverseLogList);
  prepareAdminMenuListeners();
  prepareLogPageListeners();
  autoLogin();
});

function autoLogin() {
  var url = new URL(window.location.href);
  var id = url.searchParams.get("id");
  if (!id) return;
  loadingOn();
  var token = url.searchParams.get("token");
  var pkcipher = localStorage.getItem(id);

  if (!pkcipher) {
    loadingOff();
    throw "Autologin failed: no private ley found in local storage";
  }

  var ic = new iCrypto_iCrypto();
  ic.addBlob("pkcip", pkcipher).addBlob("key", token).AESDecrypt("pkcip", "key", "privk", true, "CBC", "utf8");
  var privateKey = ic.get("privk");
  requestAdminLogin(privateKey).then(function () {}).catch(function () {});
  localStorage.removeItem(id);
} //*********ISLAND ACCESS SECTION*********************//


function addAdminHiddenService() {
  try {
    processAdminRequest({
      action: "launch_admin_hidden_service",
      permanent: true
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    toastr["warning"]("Error creating admin hidden service: " + err.message);
  }
}

function createGuest() {
  try {
    var ic = new iCrypto_iCrypto();
    ic.createNonce("n").setRSAKey("privk", admin_adminSession.privateKey, "private").privateKeySign("n", "privk", "sign").bytesToHex("n", "nhex");
    processAdminRequest({
      action: "create_guest",
      vaultID: ic.get("nhex"),
      sign: ic.get("sign"),
      permanent: true
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    toastr["warning"]("Error creating admin hidden service: " + err.message);
  }
}

function enableHiddenService(ev) {
  var onion = ev.target.parentNode.parentNode.parentNode.parentNode.children[1].innerText;

  try {
    processAdminRequest({
      action: "enable_hidden_service",
      onion: onion
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    displayServerRequestError(err);
  }
}

function disableHiddenService(ev) {
  var onion = ev.target.parentNode.parentNode.parentNode.parentNode.children[1].innerText;

  try {
    processAdminRequest({
      action: "disable_hidden_service",
      onion: onion
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    displayServerRequestError(err);
  }
}
/**
 * Deactivates and deletes hidden service
 * If it is guest hidden service - delet
 *
 * @param ev
 */


function deleteGuest(ev) {
  try {
    var row = ev.target.parentNode.parentNode.parentNode.parentNode;
    var onion = row.children[1].innerText;
    var isAdmin = /admin/i.test(row.children[3].innerText);

    if (isAdmin) {
      throw "Only applicable to guest hidden service";
    }

    if (!confirm("This will delete permanently hidden service and associated with it guest vault." + "After this operation guest will no longer be able to access this island. \n\nProceed?")) {
      return;
    }

    processAdminRequest({
      action: "delete_guest",
      onion: onion
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    toastr["warning"]("Error deleting guest: " + err);
    console.error(err);
  }
}

function deleteAdminHiddenService(ev) {
  var row = ev.target.parentNode.parentNode.parentNode.parentNode;
  var onion = row.children[1].innerText;
  var isAdmin = /admin/i.test(row.children[3].innerText);

  try {
    if (!isAdmin) {
      throw "Only applicable to admin hidden service";
    }

    processAdminRequest({
      action: "delete_hidden_service",
      onion: onion
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    toastr["warning"]("Error deleting guest: " + err);
    console.error(err);
  }
}

function displayServerRequestError(err) {
  toastr["warning"]("Error creating admin hidden service: " + err.responseText);
} //TODO finish method!
// function deleteHiddenService(ev) {
//     let onion = ev.target.previousSibling.innerHTML;
//
//     let privKey = adminSession.privateKey;
//     let pkfp = adminSession.pkfp;
//     let ic = new iCrypto();
//     ic.createNonce('n').setRSAKey("pk", privKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex');
//
//     $.ajax({
//         type: "POST",
//         url: "/admin",
//         dataType: "json",
//         data: {
//             action: "delete_hidden_service",
//             nonce: ic.get('nhex'),
//             sign: ic.get('sign'),
//             pkfp: pkfp,
//             onion: onion
//         },
//         success: processIslandHiddenServiceDeletion,
//         err: err => {
//             console.log("Error deleting hidden service: " + err);
//         }
//     });
// }

/**
 * Updates list of running Island hidden services
 * @param {Array} hiddenServices
 */


function updateHiddenServicesList(hiddenServices) {
  var hsContainer = document.querySelector("#hidden-services-wrap");
  hsContainer.innerHTML = "";
  var count = 0;

  for (var _i = 0, _Object$keys = Object.keys(hiddenServices); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var hsWrap = document.createElement("div");
    var num = document.createElement("div");
    var val = document.createElement("div");
    var del = document.createElement("div");
    hsWrap.classList.add("hidden-service");
    num.classList.add("hs-num");
    val.classList.add("hs-val");
    del.classList.add("hs-del");
    var enumer = count + 1;
    num.innerHTML = "#" + enumer;
    val.innerHTML = hiddenServices[key].id.substring(0, 16) + ".onion";
    del.innerHTML = "Delete";
    del.addEventListener("click", deleteGuest);
    hsWrap.appendChild(num);
    hsWrap.appendChild(val);
    hsWrap.appendChild(del);
    hsContainer.appendChild(hsWrap);
    count++;
  }
}

function onHiddenServiceUpdate(data) {
  var hiddenServices = JSON.parse(data.hiddenServices);
  var tableBody = dom_util_$("#hidden-services-wrap");
  tableBody.innerHTML = "";
  var enumer = 1;

  for (var _i2 = 0, _Object$keys2 = Object.keys(hiddenServices); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    var isEnabled = hiddenServices[key].enabled;
    var row = bake("tr");
    var enumEl = bake("td", {
      classes: "hs-enum",
      text: enumer
    });
    var link = bake("td", {
      classes: "hs-link",
      text: key + ".onion"
    });
    var description = extractDescription(hiddenServices[key].description);
    var hsDesc = bakeDescriptionElement(bake("td", {
      classes: "hs-desc"
    }), description);
    var hsType = bake("td", {
      classes: "hs-type",
      text: hiddenServices[key].admin ? "Admin" : "User"
    });
    var status = bake("td", {
      classes: ["hs-status", isEnabled ? "hs-status-enabled" : "hs-status-disabled"],
      text: isEnabled ? "Enabled" : "Disabled"
    });
    var actions = bakeHsRecordActionsMenu(bake("td", {
      classes: "hs-actions"
    }), hiddenServices[key].admin);
    appendChildren(row, [enumEl, link, hsDesc, hsType, status, actions]);
    tableBody.appendChild(row);
    enumer++;
    link.addEventListener("click", function (ev) {
      copyTextToBuffer(ev.target.innerText, "Onion link copied to clipboard");
    });
  }

  onHiddenServicesPageActivation();
}

function extractDescription(cipher) {
  if (cipher === undefined || cipher === "") {
    return "";
  }

  return ChatUtility_ChatUtility.decryptStandardMessage(cipher, admin_adminSession.privateKey);
}

function bakeDescriptionElement(cell, description) {
  var field = bakeEditableField("Place for description", "editable-field-gray");
  field.addEventListener("change", updateHSDescription);
  field.addEventListener("keyup", function (ev) {
    if (ev.which === 13 || ev.keyCode === 13) {
      document.activeElement.blur();
    }
  });
  field.value = description;
  cell.appendChild(field);
  return cell;
}

function updateHSDescription(ev) {
  var description = ev.target.value.trim();
  var cipher = "";
  var row = ev.target.parentNode.parentNode;
  var onion = row.children[1].innerText;

  if (description && description !== "") {
    cipher = ChatUtility_ChatUtility.encryptStandardMessage(description, admin_adminSession.publicKey);
  }

  try {
    processAdminRequest({
      action: "update_hs_description",
      onion: onion,
      description: cipher
    }, onHiddenServiceUpdate, displayServerRequestError);
  } catch (err) {
    toastr["warning"]("Error deleting guest: " + err);
    console.error(err);
  }
}
/**
 * Creates dropdown menu "Actions" for each hidden service running
 * @param cell
 * @isAdmin boolean
 * @returns {*}
 */


function bakeHsRecordActionsMenu(cell, isAdmin) {
  cell.appendChild(bakeDropdownMenu("Actions", {
    "Copy onion link": function CopyOnionLink(ev) {
      var text = ev.target.parentNode.parentNode.parentNode.parentNode.children[1].innerText;
      copyTextToBuffer(text, "Onion link copied to clipboard");
    },
    "Enable": enableHiddenService,
    "Disable": disableHiddenService,
    "Delete": isAdmin ? deleteAdminHiddenService : deleteGuest
  }));
  return cell;
}
/**
 * Copies passed text to clipboard
 * @param text - text to copy
 * @param message - message to display
 */


function copyTextToBuffer(text, message) {
  var textArea = bake("textarea");
  textArea.value = text;
  textArea.setAttribute('readonly', '');
  textArea.style.position = 'absolute';
  textArea.style.left = '-9999px';
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();

  try {
    document.execCommand("copy");
    toastr["info"](message);
  } catch (err) {
    toastr["error"]("Error copying invite code to the clipboard");
  }

  textArea.remove();
} //*********END ISLAND ACCESS SECTION*********************//
// function onionAddressFromPrivateKey(privateKey) {
//     let ic = new iCrypto();
//     ic.setRSAKey("privk", privateKey, "private").publicFromPrivate("privk", "pubk");
//     let pkraw = forge.pki.publicKeyFromPem(ic.get("pubk"));
//     let pkfp = forge.pki.getPublicKeyFingerprint(pkraw, { encoding: 'hex', md: forge.md.sha1.create() });
//     if (pkfp.length % 2 !== 0) {
//         s = '0' + s;
//     }
//     let bytes = [];
//     for (let i = 0; i < pkfp.length / 2; i = i + 2) {
//         bytes.push(parseInt(pkfp.slice(i, i + 2), 16));
//     }
//
//     return base32.encode(bytes).toLowerCase() + ".onion";
// }


function adminLogin() {
  var password = document.querySelector("#admin-password").value.trim();

  if (!password) {
    toastr["warning"]("Password is required!");
    return;
  }

  loadingOn(); //Request admin vault

  $.ajax({
    type: "GET",
    url: "/admin/vault",
    success: function () {
      var _success = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee(res) {
        var decryptedVault;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return decryptVault(res.vault, password);

              case 3:
                decryptedVault = _context.sent;
                _context.next = 6;
                return requestAdminLogin(decryptedVault.adminKey);

              case 6:
                _context.next = 13;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);
                loadingOff();
                toastr["warning"]("Login failed. Check the password and try again.");
                console.log("Login error: " + _context.t0);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 8]]);
      }));

      function success(_x) {
        return _success.apply(this, arguments);
      }

      return success;
    }(),
    error: function () {
      var _error = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee2(err) {
        return regenerator_default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                loadingOff();
                toastr["warning"]("Admin login error: " + err);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function error(_x2) {
        return _error.apply(this, arguments);
      }

      return error;
    }()
  });
}
/**
 * Decrypt the vault, get admin record, process the normal login
 * @param vaultCipher
 * @param password
 * @returns {Promise<void>}
 */


function decryptVault(vaultCipher, password) {
  return new Promise(function (resolve, reject) {
    try {
      var vault = new Vault_Vault();
      vault.initSaved(vaultCipher, password);

      if (!vault.admin || !vault.adminKey) {
        reject("Admin vault is invalid, or doesn't have a private key");
      }

      resolve(vault);
    } catch (err) {
      reject(err);
    }
  });
}

function requestAdminLogin(_x3) {
  return _requestAdminLogin.apply(this, arguments);
}

function _requestAdminLogin() {
  _requestAdminLogin = asyncToGenerator_default()(
  /*#__PURE__*/
  regenerator_default.a.mark(function _callee3(privateKey) {
    var ic;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            try {
              ic = new iCrypto_iCrypto();
              ic.createNonce('n').setRSAKey("pk", privateKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex').publicFromPrivate("pk", "pub").getPublicKeyFingerprint("pub", "pkfp");
              $.ajax({
                type: "POST",
                url: "/admin",
                dataType: "json",
                data: {
                  action: "admin_login",
                  nonce: ic.get('nhex'),
                  sign: ic.get('sign'),
                  pkfp: ic.get("pkfp")
                },
                success: function success(res) {
                  admin_adminSession = {
                    publicKey: ic.get('pub'),
                    privateKey: ic.get('pk'),
                    pkfp: ic.get('pkfp')
                  };
                  processAdminRequest = prepareRequestProcessor(admin_adminSession);
                  $('#admin-content-wrapper').css("display", "flex");
                  $('.heading__main').html("Rule your island");
                  $('#admin-login--wrapper').hide();
                  processLoginData(res);
                  displayAdminMenu(true);
                  loadingOff();
                  toastr["info"]("Admin login successfull!");
                  document.title = "Islands | Admin panel";
                },
                error: function error(err) {
                  loadingOff();
                  toastr["warning"]("Error: \n" + err.responseText);
                }
              });
            } catch (err) {
              loadingOff();
              clearAdminPrivateKey();
              toastr["warning"]("Login error: \n" + err);
            }

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _requestAdminLogin.apply(this, arguments);
}

function processLoginData(res) {
  var loggerState = res.loggerInfo.enabled === "true" || res.loggerInfo.enabled === true;
  var loggerLevel = res.loggerInfo.level;
  $("#logs-state").val(loggerState ? "true" : "false");
  $("#log-highest-level").val(loggerLevel);
  onHiddenServiceUpdate(res);
}

function setupIslandAdmin() {
  $('#island-setup').addClass('btn-loading');
  var password = document.querySelector('#new-admin-password').value;
  var confirm = document.querySelector('#new-admin-password-confirm').value;
  var error = verifyPassword(password, confirm);

  if (error) {
    toastr["warning"](error);
    loadingOff();
    return;
  }

  setupAdminContinue(password).then(function () {
    toastr["info"]("Setup successfull!!");
  }).catch(function (err) {
    toastr["error"](err);
  });
}

function setupAdminContinue(password) {
  return new Promise(function (resolve, reject) {
    loadingOn();
    var ic = new iCrypto_iCrypto();
    ic.generateRSAKeyPair("adminkp").createNonce("n").privateKeySign("n", "adminkp", "sign").bytesToHex("n", "nhex");
    var vault = new Vault_Vault();
    vault.initAdmin(password, ic.get("adminkp").privateKey);
    var vaultEncData = vault.pack();
    var vaultPublicKey = vault.publicKey;
    var adminPublicKey = ic.get("adminkp").publicKey;
    $.ajax({
      type: "POST",
      url: "/admin",
      dataType: "json",
      data: {
        action: "admin_setup",
        adminPublickKey: adminPublicKey,
        nonce: ic.get('nhex'),
        sign: ic.get("sign"),
        vault: vaultEncData.vault,
        vaultPublicKey: vaultPublicKey,
        vaultSign: vaultEncData.sign
      },
      success: function success() {
        loadingOff();
        admin_adminSession = {
          publicKey: ic.get('adminkp').publicKey,
          privateKey: ic.get('adminkp').privateKey
        };
        dom_util_$("#setup--wrapper").style.display = "none";
        dom_util_$("#registration-complete--wrapper").style.display = "flex";
        $('#island-setup').removeClass('btn-loading');
        resolve();
      },
      error: function error(err) {
        loadingOff();
        reject("Fail!" + err);
        $('#island-setup').removeClass('btn-loading');
      }
    });
  });
}

function switchView(view) {
  var views = {
    admin: function admin() {
      $('#admin-login--wrapper').css('display', "flex");
      $('#setup--wrapper').hide();
    }
  };
  views[view]();
}

function showModalNotification(headingText, bodyContent) {
  var wrapper = document.createElement("div");
  wrapper.classList.add("modal-notification--wrapper");
  var heading = document.createElement("h3");
  heading.classList.add("modal-notification--heading");
  var body = document.createElement("div");
  body.classList.add("modal-notification--body");
  heading.innerText = headingText;
  body.innerHTML = bodyContent;
  wrapper.appendChild(heading);
  wrapper.appendChild(body);
  var modalContent = document.querySelector('#code--content');
  modalContent.innerHTML = "";
  modalContent.appendChild(wrapper);
  var modalView = document.querySelector('#code-view');
  modalView.style.display = "block";
}

function closeCodeView() {
  document.querySelector("#code-view").style.display = "none";
}

function switchUpdateMode() {
  if ($('#update-from-file').prop('checked')) {
    $('#update-from-file--wrapper').css("display", "block");
    $('#update-from-git--wrapper').hide();
    $('#github-update-options--wrap').hide();
  } else {
    $('#update-from-file--wrapper').hide();
    $('#update-from-git--wrapper').css("display", "block");
    $('#github-update-options--wrap').css("display", "block");
  }
}

function processUpdateFile() {
  var file = document.querySelector("#update-file").files[0];
  getUpdateFileData(file).then(function (filedata) {
    var signature = signUpdateFile(filedata);
    document.querySelector("#pkfp").value = admin_adminSession.pkfp;
    document.querySelector("#sign").value = signature;
    document.querySelector("#select-file").innerText = "SELECTED: " + file.name;
  }).catch(function (err) {
    throw err;
  });
}

function launchUpdate() {
  if ($('#update-from-file').hasClass('active') && document.querySelector("#update-file").value) {
    loadingOn();
    updateFromFile();
  } else if ($('#update-from-git').hasClass('active')) {
    console.log("Updating from GIT");
    loadingOn();
    updateFromGithub();
  } else {
    toastr["warning"]("Please select the update file!");
  }
}

function updateFromFile() {
  var file = document.querySelector("#update-file").files[0];
  getUpdateFileData(file).then(function (filedata) {
    var signature = signUpdateFile(filedata);
    sendUpdateFromFileRequest(file, signature);
  }).catch(function (err) {
    throw err;
  });
}

function getUpdateFileData(file) {
  return new Promise(function (resolve, reject) {
    try {
      var reader = new FileReader();

      reader.onload = function () {
        resolve(reader.result);
      };

      reader.readAsBinaryString(file);
    } catch (err) {
      reject(err);
    }
  });
}

function signUpdateFile(filedata) {
  var ic = new iCrypto_iCrypto();
  ic.setRSAKey("pk", admin_adminSession.privateKey, "private").addBlob("f", filedata).privateKeySign("f", "pk", "sign");
  return ic.get("sign");
}

function getSelectedUpdateBranch() {
  var branchSelect = document.querySelector("#gh-update-branch-select");
  return branchSelect.options[branchSelect.options.selectedIndex].value;
}

function updateFromGithub() {
  var ic = new iCrypto_iCrypto();
  ic.setRSAKey("pk", admin_adminSession.privateKey, "private").createNonce("n").bytesToHex("n", "nhex").privateKeySign("n", "pk", "sign");
  var data = new FormData();
  data.append("action", "update_from_github");
  data.append("branch", getSelectedUpdateBranch());
  data.append("pkfp", admin_adminSession.pkfp);
  data.append("nonce", ic.get("nhex"));
  data.append("sign", ic.get("sign"));
  sendUpdateRequest(data);
}

function sendUpdateFromFileRequest(filedata, signature) {
  var data = new FormData();
  data.append("action", "update_from_file");
  data.append("pkfp", admin_adminSession.pkfp);
  data.append("file", document.querySelector("#update-file").files[0]);
  data.append("sign", signature);
  sendUpdateRequest(data);
}

function sendUpdateRequest(data) {
  var request = new XMLHttpRequest();
  request.open("POST", window.location.href, true);
  request.send(data);

  request.onreadystatechange = function () {
    if (request.readyState === XMLHttpRequest.DONE) {
      //
      console.log("Handling response");
      loadingOff();

      if (request.status === 200) {
        $('#close-code-view').hide();
        showModalNotification("Update completed", "<span id=timer>You will be redirected in 5 seconds</span>");
        delayedPageReload(5);
      } else {
        toastr["warning"]("Update failed: " + request.responseText);
      }
    }
  };
}

function delayedPageReload(seconds) {
  if (--seconds) {
    $("#timer").text("You will be redirected in " + seconds + (seconds > 1 ? " seconds" : " second"));
  } else {
    window.location.href = "/";
    return;
  }

  setTimeout(function () {
    delayedPageReload(seconds);
  }, 1000);
}

function loadingOnPromise() {
  return new Promise(function (resolve, reject) {
    try {
      loadingOn();
      resolve();
    } catch (err) {
      reject(err);
    }
  });
}

function loadingOn() {
  $('body').waitMe({
    effect: 'roundBounce',
    bg: 'rgba(255,255,255,0.7)',
    textPos: 'vertical',
    color: '#33b400'
  });
}

function loadingOff() {
  $('body').waitMe('hide');
}

function switchUpdateOption(event) {
  if ($(event.target).hasClass("active")) {
    return;
  }

  $(".update-option").each(function (index, el) {
    if (!$(el).hasClass("active") && $(el).attr("id") === "update-from-file") {
      $("#update-file--wrapper").css("display", "flex");
    } else if ($(el).hasClass("active") && $(el).attr("id") === "update-from-file") {
      $("#update-file--wrapper").css("display", "none");
    }

    $(el).toggleClass("active");
  });
}

function returnToChat() {
  admin_adminSession = undefined;
  clearAdminPrivateKey();
  document.location = "/";
}

function adminLogout() {
  displayAdminMenu(false);
  admin_adminSession = undefined;
  clearAdminPrivateKey();
  document.location.reload();
}

function displayAdminMenu(on) {
  if (on) {
    $('#admin-menu').css("display", "flex");
  } else {
    $('#admin-menu').hide();
  }
}

function prepareAdminMenuListeners() {
  document.querySelector("#island-admin-main-menu").childNodes.forEach(function (node) {
    node.addEventListener("click", processMainMenuClick);
  });
}

function processMainMenuClick(ev) {
  if (ev.target.classList.contains("active")) {
    return;
  }

  var menu = document.querySelector("#island-admin-main-menu");
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = menu.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      item.classList.remove("active");
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  ;
  var pages = document.querySelector("#admin-pages");
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = pages.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _item = _step2.value;

      _item.classList.remove("active");
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  ;
  var index = getElementIndex(ev.target);
  pages.children[index].classList.add("active");
  menu.children[index].classList.add("active");
  document.querySelector("#admin-section-heading").innerHTML = ev.target.innerHTML;
  runPageActivationHandler(index);
}

function runPageActivationHandler(index) {
  console.log("Running page activation handler for index: " + index);

  switch (index) {
    case 0:
      onHiddenServicesPageActivation();
      break;

    case 1:
      onLogsPageActivation();
      break;

    default:
      throw "Invaild page index";
  }
}

function onHiddenServicesPageActivation() {
  var hsExist = dom_util_$("#hidden-services-wrap").children.length === 0;
  dom_util_$("#hs-container").style.display = hsExist ? "none" : "block";
  dom_util_$("#hidden-services-empty").style.display = hsExist ? "block" : "none";
}

function onLogsPageActivation() {
  var logsExist = dom_util_$("#log-records").children.length === 0;
  dom_util_$("#logs-empty-message").style.display = logsExist ? "block" : "none";
  dom_util_$("#log-content").style.display = logsExist ? "none" : "block";
}

function clearAdminPrivateKey() {
  $("#admin-private-key").val("");
}

function getElementIndex(node) {
  var index = 0;

  while (node = node.previousElementSibling) {
    index++;
  }

  return index;
}

function loadLogs() {
  var errorsOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var download = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var privKey = admin_adminSession.privateKey;
  var pkfp = admin_adminSession.pkfp;
  var ic = new iCrypto_iCrypto();
  ic.createNonce('n').setRSAKey("pk", privKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex');
  $.ajax({
    type: "POST",
    url: "/admin",
    dataType: "json",
    data: {
      action: "load_logs",
      nonce: ic.get('nhex'),
      sign: ic.get('sign'),
      pkfp: pkfp,
      errorsOnly: errorsOnly
    },
    success: download ? downloadLogs : processLogsLoaded,
    err: function err(_err) {
      console.log("Error loading logs: " + _err);
      toastr["warning"]("Error loading logs: " + _err);
    }
  });
}

function downloadLogs(res) {
  var records = res.records;
  var el = bake("a", {
    attributes: {
      href: "data:text/plain;charset=utf-8," + encodeURIComponent(records),
      download: "islands.log"
    }
  });
  el.click();
  document.body.removeChild(el);
}

function processLogsLoaded(res) {
  var records = res.records.split("\n");
  var table = document.querySelector("#log-content").lastElementChild;
  table.innerHTML = "";
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = records[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var record = _step3.value;
      var parsed = void 0;

      try {
        parsed = JSON.parse(record);
      } catch (err) {
        continue;
      }

      var row = document.createElement("tr");
      row.classList.add(parsed.level);
      var ts = document.createElement("td");
      var level = document.createElement("td");
      var msg = document.createElement("td");
      ts.classList.add("log-timestamp");
      level.classList.add("log-level");
      msg.classList.add("log-msg");
      ts.innerHTML = parsed.timestamp;
      level.innerHTML = parsed.level;
      msg.innerHTML = parsed.message;
      row.append(ts);
      row.append(level);
      row.append(msg);
      var additionalValues = new cute_set(Object.keys(parsed)).minus(["level", "message", "timestamp"]);

      if (additionalValues.length() > 0) {
        var addCell = document.createElement("td");
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = additionalValues[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var key = _step4.value;
            var wrap = document.createElement("div");
            wrap.classList.add("log-add-value");
            var k = document.createElement("div");
            var b = document.createElement("b");
            k.classList.add("log-key");
            var v = document.createElement("div");
            v.classList.add("log-val");
            b.innerHTML = key;
            k.appendChild(b);
            v.innerHTML = parsed[key];
            wrap.appendChild(k);
            wrap.appendChild(v);
            addCell.appendChild(wrap);
            row.appendChild(addCell);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      table.appendChild(row);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  onLogsPageActivation();
  toastr["info"]("Logs loaded successfully");
}

function requestLoggerStateChange(ev) {
  var selectedElement = ev.target.options[ev.target.selectedIndex];
  var privKey = admin_adminSession.privateKey;
  var pkfp = admin_adminSession.pkfp;
  var ic = new iCrypto_iCrypto();
  ic.createNonce('n').setRSAKey("pk", privKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex');
  $.ajax({
    type: "POST",
    url: "/admin",
    dataType: "json",
    data: {
      action: "logger_state_change",
      nonce: ic.get('nhex'),
      state: selectedElement.value,
      sign: ic.get('sign'),
      pkfp: pkfp
    },
    success: function success() {
      var message = "Logger has been successfully " + (selectedElement.value === "true" ? "enabled" : "disabled");
      toastr["info"](message);
    },
    err: function err(_err2) {
      toastr["warning"]("Error loading logs: " + _err2);
    }
  });
}

function requestLoggerLevelChange(ev) {
  var selectedElement = ev.target.options[ev.target.selectedIndex];
  var privKey = admin_adminSession.privateKey;
  var pkfp = admin_adminSession.pkfp;
  var ic = new iCrypto_iCrypto();
  ic.createNonce('n').setRSAKey("pk", privKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex');
  $.ajax({
    type: "POST",
    url: "/admin",
    dataType: "json",
    data: {
      action: "log_level_change",
      nonce: ic.get('nhex'),
      level: selectedElement.value,
      sign: ic.get('sign'),
      pkfp: pkfp
    },
    success: function success() {
      toastr["info"]("Log level has been changed to: " + selectedElement.value);
    },
    err: function err(_err3) {
      toastr["warning"]("Error loading logs: " + _err3);
    }
  });
}

function prepareLogPageListeners() {
  document.querySelector("#load-logs").addEventListener("click", function () {
    loadLogs();
  });
  document.querySelector("#load-error-logs").addEventListener("click", function () {
    loadLogs(true);
  });
  document.querySelector("#logs-state").addEventListener("change", requestLoggerStateChange);
  document.querySelector("#log-highest-level").addEventListener("change", requestLoggerLevelChange);
}

function reverseLogList() {
  for (var i = 0; i < logTableBody.childNodes.length; i++) {
    logTableBody.insertBefore(logTableBody.childNodes[i], logTableBody.firstChild);
  }
}

function filterLogs(ev) {
  var filter;

  try {
    filter = new RegExp(ev.target.value);

    if (!filter || filter.length === 0) {
      return;
    }
  } catch (err) {
    return;
  }

  for (var i = 0; i < logTableBody.childNodes.length; i++) {
    var selectedField = parseInt(filterFieldSelector.options[filterFieldSelector.selectedIndex].value);
    var row = logTableBody.childNodes[i];
    var testingField = void 0;

    if (!isNaN(selectedField)) {
      testingField = row.children[selectedField] ? row.children[selectedField].innerHTML : "";
    } else {
      testingField = row.innerHTML;
    }

    filter.test(testingField) ? logTableBody.childNodes[i].classList.remove("log-row-hidden") : logTableBody.childNodes[i].classList.add("log-row-hidden");
  }
}

function clearLogs(ev) {
  var privKey = admin_adminSession.privateKey;
  var pkfp = admin_adminSession.pkfp;
  var ic = new iCrypto_iCrypto();
  ic.createNonce('n').setRSAKey("pk", privKey, 'private').privateKeySign('n', 'pk', 'sign').bytesToHex('n', 'nhex');
  $.ajax({
    type: "POST",
    url: "/admin",
    dataType: "json",
    data: {
      action: "clear_logs",
      nonce: ic.get('nhex'),
      sign: ic.get('sign'),
      pkfp: pkfp
    },
    success: function success() {
      logTableBody.innerHTML = "";
      toastr["info"]("Log level have been cleared");
    },
    err: function err(_err4) {
      toastr["warning"]("Error clearing logs: " + _err4);
    }
  });
}

function prepareRequestProcessor(adminSession) {
  return function (data, onSuccess, onError) {
    if (!data.action) {
      throw "Malformed request";
    }

    var privKey = adminSession.privateKey;
    var pkfp = adminSession.pkfp;
    var ic = new iCrypto_iCrypto();
    ic.createNonce("n").bytesToHex("n", "nhex");
    data.nonce = ic.get("nhex");
    var requestString = JSON.stringify(data);
    ic.addBlob('data', requestString).setRSAKey("pk", privKey, 'private').privateKeySign('data', 'pk', 'sign');
    $.ajax({
      type: "POST",
      url: "/admin",
      dataType: "json",
      data: {
        action: data.action,
        requestString: requestString,
        sign: ic.get('sign'),
        pkfp: pkfp
      },
      success: onSuccess,
      error: onError
    });
  };
}

/***/ })

/******/ });